/**
 * Tests for the i18n module
 * @module lib/i18n/__tests__/i18n.test
 */

import { describe, it, expect } from 'vitest';
import { t, hasTranslation, getAllTranslationKeys, getTranslationCategories } from '../index';
import { formatDate, formatDateTime, formatNumber, formatRelativeTime, formatDuration } from '../format';
import type { Locale } from '../types';

describe('t (translation function)', () => {
  describe('key resolution', () => {
    it('should resolve a top-level nested key', () => {
      expect(t('nav.dashboard', 'ja')).toBe('\u30C0\u30C3\u30B7\u30E5\u30DC\u30FC\u30C9');
      expect(t('nav.dashboard', 'en')).toBe('Dashboard');
    });

    it('should resolve deeply nested keys', () => {
      expect(t('meetings.status', 'ja')).toBe('\u30B9\u30C6\u30FC\u30BF\u30B9');
      expect(t('meetings.status', 'en')).toBe('Status');
    });

    it('should resolve all category keys', () => {
      const categories = ['nav', 'dashboard', 'meetings', 'minutes', 'actionItems', 'templates', 'common', 'auth', 'errors'];
      for (const category of categories) {
        expect(t(`${category}.title`, 'ja').length).toBeGreaterThan(0);
      }
    });

    it('should handle single-segment keys', () => {
      // Single segment keys don't exist in our dict, should fallback
      expect(t('nonexistent', 'ja')).toBe('nonexistent');
    });
  });

  describe('fallback behavior', () => {
    it('should return the key string when key is not found', () => {
      expect(t('nonexistent.key', 'ja')).toBe('nonexistent.key');
      expect(t('nonexistent.key', 'en')).toBe('nonexistent.key');
    });

    it('should return the key when intermediate path does not exist', () => {
      expect(t('foo.bar.baz', 'ja')).toBe('foo.bar.baz');
    });

    it('should return the key when accessing a non-leaf node', () => {
      // 'nav' is an object, not a string
      expect(t('nav', 'ja')).toBe('nav');
    });

    it('should return the key for empty key string', () => {
      expect(t('', 'ja')).toBe('');
    });
  });

  describe('parameter interpolation', () => {
    it('should interpolate a single parameter', () => {
      expect(t('dashboard.welcome', 'ja', { name: '\u592A\u90CE' })).toBe('\u3088\u3046\u3053\u305D\u3001\u592A\u90CE\u3055\u3093');
      expect(t('dashboard.welcome', 'en', { name: 'John' })).toBe('Welcome, John');
    });

    it('should interpolate multiple parameters', () => {
      // minutes.lastUpdated has one param, but test with a key that uses {{name}}
      expect(t('auth.loginWith', 'en', { provider: 'Google' })).toBe('Login with Google');
      expect(t('auth.loginWith', 'ja', { provider: 'Google' })).toBe('Google\u3067\u30ED\u30B0\u30A4\u30F3');
    });

    it('should leave unmatched placeholders intact', () => {
      expect(t('dashboard.welcome', 'en', {})).toBe('Welcome, {{name}}');
    });

    it('should handle params when key is not found (returns key)', () => {
      expect(t('nonexistent', 'ja', { name: 'test' })).toBe('nonexistent');
    });

    it('should handle empty string parameter values', () => {
      expect(t('dashboard.welcome', 'en', { name: '' })).toBe('Welcome, ');
    });

    it('should not interpolate partial placeholder syntax', () => {
      // The translation string itself doesn't have broken placeholders,
      // but we can verify the regex is strict
      expect(t('minutes.generatedBy', 'en', { name: 'AI' })).toBe('Generated by AI');
    });
  });

  describe('locale handling', () => {
    it('should return different values for different locales', () => {
      const jaValue = t('common.save', 'ja');
      const enValue = t('common.save', 'en');
      expect(jaValue).not.toBe(enValue);
      expect(jaValue).toBe('\u4FDD\u5B58');
      expect(enValue).toBe('Save');
    });

    it('should work with both supported locales', () => {
      const locales: Locale[] = ['ja', 'en'];
      for (const locale of locales) {
        expect(t('nav.meetings', locale)).not.toBe('nav.meetings');
      }
    });
  });
});

describe('hasTranslation', () => {
  it('should return true for existing keys', () => {
    expect(hasTranslation('nav.dashboard', 'ja')).toBe(true);
    expect(hasTranslation('nav.dashboard', 'en')).toBe(true);
  });

  it('should return false for non-existing keys', () => {
    expect(hasTranslation('nonexistent.key', 'ja')).toBe(false);
    expect(hasTranslation('nonexistent.key', 'en')).toBe(false);
  });

  it('should return false for object nodes (non-leaf)', () => {
    expect(hasTranslation('nav', 'ja')).toBe(false);
  });
});

describe('getTranslationCategories', () => {
  it('should return all top-level categories', () => {
    const categories = getTranslationCategories('ja');
    expect(categories).toContain('nav');
    expect(categories).toContain('dashboard');
    expect(categories).toContain('meetings');
    expect(categories).toContain('minutes');
    expect(categories).toContain('actionItems');
    expect(categories).toContain('templates');
    expect(categories).toContain('common');
    expect(categories).toContain('auth');
    expect(categories).toContain('errors');
  });

  it('should return same categories for both locales', () => {
    const jaCategories = getTranslationCategories('ja').sort();
    const enCategories = getTranslationCategories('en').sort();
    expect(jaCategories).toEqual(enCategories);
  });
});

describe('getAllTranslationKeys', () => {
  it('should return all leaf keys in dot notation', () => {
    const keys = getAllTranslationKeys('ja');
    expect(keys).toContain('nav.dashboard');
    expect(keys).toContain('common.save');
    expect(keys).toContain('errors.notFound');
  });

  it('should not include non-leaf keys', () => {
    const keys = getAllTranslationKeys('ja');
    expect(keys).not.toContain('nav');
    expect(keys).not.toContain('common');
  });

  it('should return sorted keys', () => {
    const keys = getAllTranslationKeys('ja');
    const sorted = [...keys].sort();
    expect(keys).toEqual(sorted);
  });
});

describe('translation key completeness', () => {
  it('should have identical keys in ja and en locales', () => {
    const jaKeys = getAllTranslationKeys('ja');
    const enKeys = getAllTranslationKeys('en');

    const missingInEn = jaKeys.filter((key) => !enKeys.includes(key));
    const missingInJa = enKeys.filter((key) => !jaKeys.includes(key));

    expect(missingInEn).toEqual([]);
    expect(missingInJa).toEqual([]);
  });

  it('should have the same number of keys in both locales', () => {
    const jaKeys = getAllTranslationKeys('ja');
    const enKeys = getAllTranslationKeys('en');
    expect(jaKeys.length).toBe(enKeys.length);
  });

  it('should have non-empty values for all keys in ja', () => {
    const keys = getAllTranslationKeys('ja');
    for (const key of keys) {
      const value = t(key, 'ja');
      expect(value.length, `Key "${key}" has empty value in ja`).toBeGreaterThan(0);
    }
  });

  it('should have non-empty values for all keys in en', () => {
    const keys = getAllTranslationKeys('en');
    for (const key of keys) {
      const value = t(key, 'en');
      expect(value.length, `Key "${key}" has empty value in en`).toBeGreaterThan(0);
    }
  });

  it('should have matching parameter placeholders between locales', () => {
    const jaKeys = getAllTranslationKeys('ja');
    const paramRegex = /\{\{(\w+)\}\}/g;

    function extractParams(value: string): string[] {
      const params: string[] = [];
      let match: RegExpExecArray | null;
      while ((match = paramRegex.exec(value)) !== null) {
        if (match[1] !== undefined && match[1] !== '') {
          params.push(match[1]);
        }
      }
      paramRegex.lastIndex = 0;
      return params.sort();
    }

    for (const key of jaKeys) {
      const jaValue = t(key, 'ja');
      const enValue = t(key, 'en');

      const jaParams = extractParams(jaValue);
      const enParams = extractParams(enValue);

      expect(jaParams, `Parameter mismatch for key "${key}"`).toEqual(enParams);
    }
  });
});

describe('formatDate', () => {
  it('should format date in Japanese locale', () => {
    const result = formatDate(new Date('2025-03-15'), 'ja');
    expect(result).toContain('2025');
    expect(result).toContain('3');
    expect(result).toContain('15');
  });

  it('should format date in English locale', () => {
    const result = formatDate(new Date('2025-03-15'), 'en');
    expect(result).toContain('2025');
    expect(result).toContain('3');
    expect(result).toContain('15');
  });

  it('should accept ISO string input', () => {
    const result = formatDate('2025-06-01', 'ja');
    expect(result).toContain('2025');
  });

  it('should return empty string for invalid date', () => {
    expect(formatDate('invalid-date', 'ja')).toBe('');
    expect(formatDate(new Date('invalid'), 'en')).toBe('');
  });

  it('should accept custom options', () => {
    const result = formatDate(new Date('2025-03-15'), 'en', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
    expect(result).toContain('March');
  });
});

describe('formatDateTime', () => {
  it('should include time in the output', () => {
    const result = formatDateTime(new Date('2025-03-15T14:30:00'), 'ja');
    expect(result).toContain('14');
    expect(result).toContain('30');
  });

  it('should format in English locale', () => {
    const result = formatDateTime(new Date('2025-03-15T14:30:00'), 'en');
    expect(result).toContain('15');
  });
});

describe('formatNumber', () => {
  it('should format numbers with locale grouping', () => {
    const jaResult = formatNumber(1234567, 'ja');
    expect(jaResult).toContain('1,234,567');
  });

  it('should format numbers in English', () => {
    const enResult = formatNumber(1234567, 'en');
    expect(enResult).toContain('1,234,567');
  });

  it('should handle zero', () => {
    expect(formatNumber(0, 'ja')).toBe('0');
    expect(formatNumber(0, 'en')).toBe('0');
  });

  it('should handle negative numbers', () => {
    const result = formatNumber(-1000, 'en');
    expect(result).toContain('1,000');
    expect(result).toContain('-');
  });

  it('should accept custom options (percent)', () => {
    const result = formatNumber(0.85, 'ja', { style: 'percent' });
    expect(result).toContain('85');
    expect(result).toContain('%');
  });

  it('should accept custom options (currency)', () => {
    const result = formatNumber(1000, 'ja', { style: 'currency', currency: 'JPY' });
    expect(result).toContain('1,000');
  });
});

describe('formatRelativeTime', () => {
  const baseTime = new Date('2025-06-15T12:00:00Z');

  it('should format seconds ago', () => {
    const date = new Date('2025-06-15T11:59:30Z');
    const result = formatRelativeTime(date, 'en', baseTime);
    expect(result).toContain('second');
  });

  it('should format minutes ago', () => {
    const date = new Date('2025-06-15T11:57:00Z');
    const result = formatRelativeTime(date, 'ja', baseTime);
    expect(result).toContain('3');
    expect(result).toContain('\u5206');
  });

  it('should format hours ago', () => {
    const date = new Date('2025-06-15T10:00:00Z');
    const result = formatRelativeTime(date, 'en', baseTime);
    expect(result).toContain('2');
    expect(result).toContain('hour');
  });

  it('should format days ago', () => {
    const date = new Date('2025-06-12T12:00:00Z');
    const result = formatRelativeTime(date, 'ja', baseTime);
    expect(result).toContain('3');
    expect(result).toContain('\u65E5');
  });

  it('should format future dates', () => {
    const date = new Date('2025-06-16T12:00:00Z');
    const result = formatRelativeTime(date, 'en', baseTime);
    // Should indicate future ("in 1 day" or "tomorrow")
    expect(result.length).toBeGreaterThan(0);
  });

  it('should return empty string for invalid date', () => {
    expect(formatRelativeTime('invalid', 'ja', baseTime)).toBe('');
  });

  it('should accept ISO string input', () => {
    const result = formatRelativeTime('2025-06-15T11:55:00Z', 'en', baseTime);
    expect(result).toContain('5');
    expect(result).toContain('minute');
  });

  it('should handle same time (now)', () => {
    const result = formatRelativeTime(baseTime, 'en', baseTime);
    // Should indicate "now" or "0 seconds"
    expect(result.length).toBeGreaterThan(0);
  });
});

describe('formatDuration', () => {
  it('should format hours and minutes in Japanese', () => {
    expect(formatDuration(5400000, 'ja')).toBe('1\u6642\u959330\u5206');
  });

  it('should format hours only in Japanese', () => {
    expect(formatDuration(3600000, 'ja')).toBe('1\u6642\u9593');
  });

  it('should format minutes only in Japanese', () => {
    expect(formatDuration(300000, 'ja')).toBe('5\u5206');
  });

  it('should format hours and minutes in English', () => {
    expect(formatDuration(5400000, 'en')).toBe('1 hr, 30 min');
  });

  it('should format hours only in English', () => {
    expect(formatDuration(3600000, 'en')).toBe('1 hr');
  });

  it('should format minutes only in English', () => {
    expect(formatDuration(300000, 'en')).toBe('5 min');
  });

  it('should handle zero duration', () => {
    expect(formatDuration(0, 'ja')).toBe('0\u5206');
    expect(formatDuration(0, 'en')).toBe('0 min');
  });

  it('should handle large durations', () => {
    // 25 hours 45 minutes
    const ms = (25 * 60 + 45) * 60 * 1000;
    expect(formatDuration(ms, 'en')).toBe('25 hr, 45 min');
  });
});
